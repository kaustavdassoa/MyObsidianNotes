## Overview

This practical lecture guides learners through implementing a simple workflow using the LangGraph framework. The instructor demonstrates how to build a basic graph with nodes, edges, state management, and conditional routing—without using any LLMs, focusing purely on the graph structure and execution logic.

## Detailed Summary

**Workflow Example**  
The lecture uses a simple sports decision workflow: Start → Start Play → Conditional Decision (Badminton or Cricket) → End. This demonstrates the fundamental concepts of graph construction.[](https://www.udemy.com/course/complete-agentic-ai-bootcamp-with-langgraph-and-langchain/learn/lecture/48879729#notes)​

**Core Components Explained**

1. **Nodes**
    
    - Nodes are Python functions that perform specific tasks
        
    - Each node receives the current state as its first argument
        
    - In the example: `start_play`, `badminton`, and `cricket` are three separate nodes
        
    - Nodes update and return the state schema, allowing information to flow through the graph[](https://www.udemy.com/course/complete-agentic-ai-bootcamp-with-langgraph-and-langchain/learn/lecture/48879729#notes)​
        
2. **Edges**
    
    - Edges are routes/connections between nodes
        
    - Simple edges provide straightforward connections between nodes
        
    - Conditional edges allow branching logic based on conditions
        
    - They determine the flow of execution through the graph[](https://www.udemy.com/course/complete-agentic-ai-bootcamp-with-langgraph-and-langchain/learn/lecture/48879729#notes)​
        
3. **State Schema**
    
    - Defines the data structure passed between nodes
        
    - Created using Python's `TypeDict` from `typing_extensions`
        
    - Serves as the input schema for all nodes and edges
        
    - Contains properties that persist across node executions (e.g., `graph_info`)
        
    - Makes the application "stateful"—information flows between nodes through state[](https://www.udemy.com/course/complete-agentic-ai-bootcamp-with-langgraph-and-langchain/learn/lecture/48879729#notes)​
        
4. **StateGraph**
    
    - The graph structure class that ties everything together
        
    - Requires initialization with the state class
        
    - Nodes and edges are added to this structure
        
    - Requires compilation before execution[](https://www.udemy.com/course/complete-agentic-ai-bootcamp-with-langgraph-and-langchain/learn/lecture/48879729#notes)​
        

**Implementation Steps Demonstrated**

1. **Define State Schema**
    
    text
    
    `- Create a TypeDict class with properties - Example: graph_info (string type) to hold workflow information`
    
2. **Create Node Functions**
    
    - `start_play()`: Initial node that initiates the workflow
        
    - `cricket()`: Node for cricket selection
        
    - `badminton()`: Node for badminton selection
        
    - Each updates the state with progress messages
        
3. **Implement Conditional Logic**
    
    - `random_play()` function uses conditional decision logic
        
    - Uses Python's `Literal` type to return constant values
        
    - Returns either "cricket" or "badminton" based on conditions
        
    - Node names in conditionals must match exactly[](https://www.udemy.com/course/complete-agentic-ai-bootcamp-with-langgraph-and-langchain/learn/lecture/48879729#notes)​
        
4. **Random Routing Example**
    
    text
    
    `- Uses random.random() > 0.5 condition - Returns "cricket" if true, "badminton" if false - This function is called from start_play node to determine next edge`
    

**Graph Construction Process**  
The instructor outlines the steps for building the complete graph (to be completed in the next lecture):

- Initialize StateGraph with the state class
    
- Add nodes to the graph
    
- Connect edges between nodes
    
- Add start and end nodes
    
- Compile the graph[](https://www.udemy.com/course/complete-agentic-ai-bootcamp-with-langgraph-and-langchain/learn/lecture/48879729#notes)​
    

## Key Takeaways

1. **Nodes are Python functions** that accept state as the first argument and perform specific tasks within the workflow
    
2. **State schema defines the data contract** between nodes using TypeDict, creating a stateful application where information persists across node executions
    
3. **Edges connect nodes** and can be either simple (direct connections) or conditional (based on logic), controlling the flow of execution
    
4. **Conditional routing** is achieved through dedicated decision functions that return literal values matching exact node names
    
5. **TypeDict from typing_extensions** provides type hints for state properties, enabling proper dictionary-based state representation
    
6. **No LLMs are required** for basic graph construction—graphs work on pure logic and conditional routing before LLM integration
    
7. **State is immutable in terms of structure**—nodes return updated dictionaries with modified values that flow to the next node
    
8. **Information persistence** is achieved by returning previous state values plus new information (e.g., "I'm planning to play" + "cricket")
    
9. **The workflow structure** (Start → Process → Decision → Branches → End) is fundamental and applies to all LangGraph applications
    
10. **Step-by-step development** from simple workflows (without LLMs) to complex ones builds a solid foundation for understanding stateful, multi-step agent applications
    
11. **Graph compilation** is a necessary final step before execution, which will be covered in the next lecture (Lecture 93)
    
12. **Literal type hints** (`Literal["cricket", "badminton"]`) ensure that conditional edges return only valid node names, preventing routing errors