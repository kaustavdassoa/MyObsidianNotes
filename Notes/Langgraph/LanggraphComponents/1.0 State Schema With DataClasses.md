**Overview:**  
LangGraph: TypeDict and DataClasses help define different state schema approaches.

**Key Content:**  
TypeDict or DataClasses both can be used to define the state of the schema , however there is a core difference  between typeDict and Data Classes - where TypeDict uses key-value pair dictionaries and Data Classes uses structured class objects.

e.g., In TypeDict we need to access name variable withing sate like this`state['name']`, whereas Data Classes allow direct attribute access (e.g., `state.name`). Neither TypeDict nor Data Classes enforce type constraints at runtime—they are merely type hints that help catch errors during development.

## Key Takeaways:

1. **TypeDict Approach**: Uses `from typing import TypeDict` to define state schemas as dictionary-based structures. Variables are accessed using dictionary notation (`state['variable_name']`). Type hints are provided but not enforced at runtime.
2. **Data Classes Approach**: Uses `from dataclasses import dataclass` decorator to define structured state classes. Variables are accessed as object attributes (`state.variable_name`). Offers more conventional Python class syntax but maintains the same runtime behavior as TypeDict.
3. **Type Hints Are Not Enforced**: Both methods allow passing invalid data types at runtime. For example, defining `name: str` but passing `123` will execute without errors (unless the code logic fails with the wrong type).
4. **Reducer Pattern**: Used for state variables that accumulate data across node executions (e.g., appending messages instead of overwriting them).
5. **Graph Workflow Structure**: Demonstrates using `StateGraph`, `add_node()` for nodes, conditional edges with `add_conditional_edges()`, and regular edges with `add_edge()`.
6. **Conditional Routing**: Shows how to implement decision logic in graphs using functions like `decide_play()` that return literal values to route execution paths.
7. **Pydantic for Runtime Validation**: The instructor previews that Pydantic (covered in the next lecture) is needed to enforce type validation at runtime, solving the limitation of TypeDict and Data Classes.
8. **State Variable Updates**: Demonstrates how nodes update state variables by returning key-value pairs that get merged into the graph state during execution.
9. **Flexibility in State Design**: Illustrates that state schemas can contain multiple variables of different types, and each node can selectively update specific state variables.
10. **Invocation Differences**: TypeDict is invoked using dictionary syntax (e.g., `{"name": "Krish"}`), while Data Classes use class instantiation syntax (e.g., `DataClassState(name="Krish")`).

**Next Steps Preview:** The instructor indicates the next lecture will cover Pydantic for adding runtime type validation and enforcement to state schemas.